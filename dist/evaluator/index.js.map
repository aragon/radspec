{"version":3,"sources":["../../src/evaluator/index.js"],"names":["TypedValue","constructor","type","value","objValue","castValue","types","isInteger","BN","isBN","hex","toString","Web3Utils","isAddress","Error","toChecksumAddress","Number","Evaluator","ast","bindings","availableHelpers","eth","ethNode","to","returnType","Eth","DEFAULT_ETH_NODE","helpers","HelperManager","evaluateNodes","nodes","Promise","all","map","evaluateNode","bind","node","body","evaluatedNode","castType","length","Math","ceil","panic","left","right","operator","add","sub","mul","pow","div","mod","leftValue","rightValue","bothTypesAddress","bothTypesBytes","bytes","isType","toBN","gt","gte","lt","lte","eq","predicate","leftFalsey","isZero","startsWith","test","target","checkAddressChecksum","inputs","outputs","call","ABI","encodeFunctionCall","name","callee","input","data","then","decodeParameter","helperName","exists","result","execute","evaluator","hasOwnProperty","binding","evaluate","evaluatedNodes","Array","isArray","join","msg","options"],"mappings":"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","sourcesContent":["/**\n * @module radspec/evaluator\n */\n\nimport ABI from \"web3-eth-abi\";\nimport Eth from \"web3-eth\";\nimport Web3Utils from \"web3-utils\";\nimport BN from \"bn.js\";\nimport types from \"../types\";\nimport HelperManager from \"../helpers/HelperManager\";\nimport { DEFAULT_ETH_NODE } from \"../defaults\";\n\n/**\n * A value coupled with a type\n *\n * @class TypedValue\n * @param {string} type The type of the value\n * @param {*} value The value\n * @property {string} type\n * @property {*} value\n */\nclass TypedValue {\n  constructor(type, value, objValue = null) {\n    this.type = type;\n    this.value = value;\n    this.objValue = objValue;\n  }\n\n  castValue(type) {\n    if (types.isInteger(type) && !BN.isBN(this.value)) {\n      this.value = new BN(this.value);\n      this.objValue = { hex: `0x${this.value.toString(16)}` };\n    }\n\n    if (type === \"address\") {\n      if (!Web3Utils.isAddress(this.value)) {\n        throw new Error(`Invalid address \"${this.value}\"`);\n      }\n\n      this.value = Web3Utils.toChecksumAddress(this.value);\n    }\n\n    if (type === \"string\") {\n      this.value = `${this.value}`;\n    }\n\n    if (type === \"number\") {\n      this.value = Number(this.value);\n    }\n  }\n\n  /**\n   * Get the string representation of the wrapped value\n   *\n   * @return {string}\n   */\n  toString() {\n    return this.value.toString();\n  }\n}\n\n/**\n * Walks an AST and evaluates each node.\n *\n * @class Evaluator\n * @param {radspec/parser/AST} ast The AST to evaluate\n * @param {radspec/Bindings} bindings An object of bindings and their values\n * @param {?Object} options An options object\n * @param {?Object} options.availablehelpers Available helpers\n * @param {?Web3} options.eth Web3 instance (used over options.ethNode)\n * @param {?string} options.ethNode The URL to an Ethereum node\n * @param {?string} options.to The destination address for this expression's transaction\n * @property {radspec/parser/AST} ast\n * @property {radspec/Bindings} bindings\n */\nexport class Evaluator {\n  constructor(\n    ast,\n    bindings,\n    { availableHelpers = {}, eth, ethNode, to, returnType = \"string\" } = {}\n  ) {\n    this.ast = ast;\n    this.bindings = bindings;\n    this.eth = eth || new Eth(ethNode || DEFAULT_ETH_NODE);\n    this.to = to && new TypedValue(\"address\", to);\n    this.helpers = new HelperManager(availableHelpers);\n    this.returnType = returnType;\n  }\n\n  /**\n   * Evaluate an array of AST nodes.\n   *\n   * @param  {Array<radspec/parser/Node>} nodes\n   * @return {Promise<Array<string>>}\n   */\n  async evaluateNodes(nodes) {\n    return Promise.all(nodes.map(this.evaluateNode.bind(this)));\n  }\n\n  /**\n   * Evaluate a single node.\n   *\n   * @param  {radspec/parser/Node} node\n   * @return {Promise<TypedValue>}\n   */\n  async evaluateNode(node) {\n    if (node.type === \"ExpressionStatement\") {\n      return await this.evaluateNodes(node.body);\n    }\n\n    if (node.type === \"GroupedExpression\") {\n      const evaluatedNode = await this.evaluateNode(node.body);\n\n      if (node.castType) {\n        evaluatedNode.castValue(node.castType);\n      }\n\n      return evaluatedNode;\n    }\n\n    if (node.type === \"MonologueStatement\") {\n      return new TypedValue(\"string\", node.value);\n    }\n\n    if (node.type === \"StringLiteral\") {\n      return new TypedValue(\"string\", node.value || \"\");\n    }\n\n    if (node.type === \"NumberLiteral\") {\n      return new TypedValue(\"int256\", node.value);\n    }\n\n    if (node.type === \"BytesLiteral\") {\n      const length = Math.ceil((node.value.length - 2) / 2);\n      if (length > 32) {\n        this.panic(\"Byte literal represents more than 32 bytes\");\n      }\n\n      return new TypedValue(`bytes${length}`, node.value);\n    }\n\n    if (node.type === \"BoolLiteral\") {\n      return new TypedValue(\"bool\", node.value === \"true\");\n    }\n\n    if (node.type === \"BinaryExpression\") {\n      const left = await this.evaluateNode(node.left);\n      const right = await this.evaluateNode(node.right);\n\n      // String concatenation\n      if (\n        (left.type === \"string\" || right.type === \"string\") &&\n        node.operator === \"PLUS\"\n      ) {\n        return new TypedValue(\n          \"string\",\n          left.value.toString() + right.value.toString()\n        );\n      }\n\n      // TODO Additionally check that the type is signed if subtracting\n      if (!types.isInteger(left.type) || !types.isInteger(right.type)) {\n        this.panic(\n          `Cannot evaluate binary expression \"${\n            node.operator\n          }\" for non-integer types \"${left.type}\" and \"${right.type}\"`\n        );\n      }\n\n      switch (node.operator) {\n        case \"PLUS\":\n          return new TypedValue(\"int256\", left.value.add(right.value));\n        case \"MINUS\":\n          return new TypedValue(\"int256\", left.value.sub(right.value));\n        case \"STAR\":\n          return new TypedValue(\"int256\", left.value.mul(right.value));\n        case \"POWER\":\n          return new TypedValue(\"int256\", left.value.pow(right.value));\n        case \"SLASH\":\n          return new TypedValue(\"int256\", left.value.div(right.value));\n        case \"MODULO\":\n          return new TypedValue(\"int256\", left.value.mod(right.value));\n        default:\n          this.panic(`Undefined binary operator \"${node.operator}\"`);\n      }\n    }\n\n    if (node.type === \"ComparisonExpression\") {\n      const left = await this.evaluateNode(node.left);\n      const right = await this.evaluateNode(node.right);\n\n      let leftValue = left.value;\n      let rightValue = right.value;\n\n      const bothTypesAddress = (left, right) =>\n        // isAddress is true if type is address or bytes with size less than 20\n        types.isAddress(left.type) && types.isAddress(right.type);\n\n      const bothTypesBytes = (left, right) =>\n        types.types.bytes.isType(left.type) &&\n        types.types.bytes.isType(right.type);\n\n      // Conversion to BN for comparison will happen if:\n      // - Both types are addresses or bytes of any size (can be different sizes)\n      // - If one of the types is an address and the other bytes with size less than 20\n      if (bothTypesAddress(left, right) || bothTypesBytes(left, right)) {\n        leftValue = Web3Utils.toBN(leftValue);\n        rightValue = Web3Utils.toBN(rightValue);\n      } else if (!types.isInteger(left.type) || !types.isInteger(right.type)) {\n        this.panic(\n          `Cannot evaluate binary expression \"${\n            node.operator\n          }\" for non-integer or fixed-size bytes types \"${left.type}\" and \"${\n            right.type\n          }\"`\n        );\n      }\n\n      switch (node.operator) {\n        case \"GREATER\":\n          return new TypedValue(\"bool\", leftValue.gt(rightValue));\n        case \"GREATER_EQUAL\":\n          return new TypedValue(\"bool\", leftValue.gte(rightValue));\n        case \"LESS\":\n          return new TypedValue(\"bool\", leftValue.lt(rightValue));\n        case \"LESS_EQUAL\":\n          return new TypedValue(\"bool\", leftValue.lte(rightValue));\n        case \"EQUAL_EQUAL\":\n          return new TypedValue(\"bool\", leftValue.eq(rightValue));\n        case \"BANG_EQUAL\":\n          return new TypedValue(\"bool\", !leftValue.eq(rightValue));\n      }\n    }\n\n    if (node.type === \"TernaryExpression\") {\n      if ((await this.evaluateNode(node.predicate)).value) {\n        return this.evaluateNode(node.left);\n      }\n\n      return this.evaluateNode(node.right);\n    }\n\n    if (node.type === \"DefaultExpression\") {\n      const left = await this.evaluateNode(node.left);\n      let leftFalsey;\n\n      if (types.isInteger(left.type)) {\n        leftFalsey = left.value.isZero();\n      } else if (left.type === \"address\" || left.type.startsWith(\"bytes\")) {\n        leftFalsey = /^0x[0]*$/.test(left.value);\n      } else {\n        leftFalsey = !left.value;\n      }\n\n      return leftFalsey ? this.evaluateNode(node.right) : left;\n    }\n\n    if (node.type === \"CallExpression\") {\n      // TODO Add a check for number of return values (can only be 1 for now)\n      let target;\n\n      // Inject self\n      if (node.target.type === \"Identifier\" && node.target.value === \"self\") {\n        target = this.to;\n      } else {\n        target = await this.evaluateNode(node.target);\n      }\n\n      if (target.type !== \"bytes20\" && target.type !== \"address\") {\n        this.panic(\"Target of call expression was not an address\");\n      } else if (!Web3Utils.checkAddressChecksum(target.value)) {\n        this.panic(`Checksum failed for address \"${target.value}\"`);\n      }\n\n      const inputs = await this.evaluateNodes(node.inputs);\n      const outputs = node.outputs;\n\n      const call = ABI.encodeFunctionCall(\n        {\n          name: node.callee,\n          type: \"function\",\n\n          inputs,\n          outputs\n        },\n        inputs.map(input => input.value)\n      );\n\n      const returnType = outputs[0].type;\n      return this.eth\n        .call({\n          to: target.value,\n          data: call\n        })\n        .then(\n          data =>\n            new TypedValue(returnType, ABI.decodeParameter(returnType, data))\n        );\n    }\n\n    if (node.type === \"HelperFunction\") {\n      const helperName = node.name;\n\n      if (!this.helpers.exists(helperName)) {\n        this.panic(`${helperName} helper function is not defined`);\n      }\n\n      const inputs = await this.evaluateNodes(node.inputs);\n      const result = await this.helpers.execute(helperName, inputs, {\n        eth: this.eth,\n        evaluator: this\n      });\n\n      return new TypedValue(result.type, result.value, result.objValue);\n    }\n\n    if (node.type === \"Identifier\") {\n      if (node.value === \"self\") {\n        return this.to;\n      }\n\n      if (!this.bindings.hasOwnProperty(node.value)) {\n        this.panic(`Undefined binding \"${node.value}\"`);\n      }\n\n      const binding = this.bindings[node.value];\n      return new TypedValue(binding.type, binding.value);\n    }\n  }\n\n  /**\n   * Evaluate the entire AST.\n   *\n   * @return {*}\n   */\n  async evaluate() {\n    const evaluatedNodes = await this.evaluateNodes(this.ast.body);\n\n    if (this.returnType === \"object\") {\n      return evaluatedNodes.map(evaluatedNode => {\n        evaluatedNode = Array.isArray(evaluatedNode)\n          ? evaluatedNode[0]\n          : evaluatedNode;\n\n        return {\n          value: evaluatedNode.objValue || evaluatedNode.value,\n          type: evaluatedNode.type\n        };\n      });\n    }\n\n    return evaluatedNodes.join(\"\");\n  }\n\n  /**\n   * Report an error and abort evaluation.\n   *\n   * @param  {string} msg\n   */\n  panic(msg) {\n    throw new Error(`Error: ${msg}`);\n  }\n}\n\n/**\n * Evaluates an AST\n *\n * @memberof radspec/evaluator\n * @param {radspec/parser/AST} ast The AST to evaluate\n * @param {radspec/Bindings} bindings An object of bindings and their values\n * @param {?Object} options An options object\n * @param {?string} options.ethNode The URL to an Ethereum node\n * @param {?string} options.to The destination address for this expression's transaction\n * @return {string}\n */\nexport function evaluate(ast, bindings, options) {\n  return new Evaluator(ast, bindings, options).evaluate();\n}\n"],"file":"index.js"}