{"version":3,"sources":["../../src/evaluator/index.js"],"names":["TypedValue","constructor","type","value","types","isInteger","BN","isBN","Web3Utils","isAddress","Error","toChecksumAddress","toString","Evaluator","ast","bindings","availableHelpers","eth","ethNode","to","returnType","Eth","DEFAULT_ETH_NODE","helpers","HelperManager","evaluateNodes","nodes","Promise","all","map","evaluateNode","bind","node","body","join","length","Math","ceil","panic","left","right","operator","add","sub","mul","pow","div","mod","leftValue","rightValue","bothTypesAddress","bothTypesBytes","bytes","isType","toBN","gt","gte","lt","lte","eq","predicate","leftFalsey","isZero","startsWith","test","target","checkAddressChecksum","inputs","outputs","call","ABI","encodeFunctionCall","name","callee","input","data","then","decodeParameter","helperName","exists","result","execute","evaluator","hasOwnProperty","binding","evaluate","evaluatedNodes","msg","options"],"mappings":"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","sourcesContent":["/**\n * @module radspec/evaluator\n */\n\nimport ABI from \"web3-eth-abi\";\nimport Eth from \"web3-eth\";\nimport Web3Utils from \"web3-utils\";\nimport BN from \"bn.js\";\nimport types from \"../types\";\nimport HelperManager from \"../helpers/HelperManager\";\nimport { DEFAULT_ETH_NODE } from \"../defaults\";\n\n/**\n * A value coupled with a type\n *\n * @class TypedValue\n * @param {string} type The type of the value\n * @param {*} value The value\n * @property {string} type\n * @property {*} value\n */\nclass TypedValue {\n  constructor(type, value) {\n    this.type = type;\n    this.value = value;\n\n    if (types.isInteger(this.type) && !BN.isBN(this.value)) {\n      this.value = new BN(this.value);\n    }\n\n    if (this.type === \"address\") {\n      if (!Web3Utils.isAddress(this.value)) {\n        throw new Error(`Invalid address \"${this.value}\"`);\n      }\n      this.value = Web3Utils.toChecksumAddress(this.value);\n    }\n  }\n\n  /**\n   * Get the string representation of the wrapped value\n   *\n   * @return {string}\n   */\n  toString() {\n    return this.value.toString();\n  }\n}\n\n/**\n * Walks an AST and evaluates each node.\n *\n * @class Evaluator\n * @param {radspec/parser/AST} ast The AST to evaluate\n * @param {radspec/Bindings} bindings An object of bindings and their values\n * @param {?Object} options An options object\n * @param {?Object} options.availablehelpers Available helpers\n * @param {?Web3} options.eth Web3 instance (used over options.ethNode)\n * @param {?string} options.ethNode The URL to an Ethereum node\n * @param {?string} options.to The destination address for this expression's transaction\n * @property {radspec/parser/AST} ast\n * @property {radspec/Bindings} bindings\n */\nexport class Evaluator {\n  constructor(\n    ast,\n    bindings,\n    { availableHelpers = {}, eth, ethNode, to, returnType = \"string\" } = {}\n  ) {\n    this.ast = ast;\n    this.bindings = bindings;\n    this.eth = eth || new Eth(ethNode || DEFAULT_ETH_NODE);\n    this.to = to && new TypedValue(\"address\", to);\n    this.helpers = new HelperManager(availableHelpers);\n    this.returnType = returnType;\n  }\n\n  /**\n   * Evaluate an array of AST nodes.\n   *\n   * @param  {Array<radspec/parser/Node>} nodes\n   * @return {Promise<Array<string>>}\n   */\n  async evaluateNodes(nodes) {\n    return Promise.all(nodes.map(this.evaluateNode.bind(this)));\n  }\n\n  /**\n   * Evaluate a single node.\n   *\n   * @param  {radspec/parser/Node} node\n   * @return {Promise<string>}\n   */\n  async evaluateNode(node) {\n    if (node.type === \"ExpressionStatement\") {\n      return (await this.evaluateNodes(node.body)).join(\" \");\n    }\n\n    if (node.type === \"GroupedExpression\") {\n      return this.evaluateNode(node.body);\n    }\n\n    if (node.type === \"MonologueStatement\") {\n      return new TypedValue(\"string\", node.value);\n    }\n\n    if (node.type === \"StringLiteral\") {\n      return new TypedValue(\"string\", node.value || \"\");\n    }\n\n    if (node.type === \"NumberLiteral\") {\n      return new TypedValue(\"int256\", node.value);\n    }\n\n    if (node.type === \"BytesLiteral\") {\n      const length = Math.ceil((node.value.length - 2) / 2);\n      if (length > 32) {\n        this.panic(\"Byte literal represents more than 32 bytes\");\n      }\n\n      return new TypedValue(`bytes${length}`, node.value);\n    }\n\n    if (node.type === \"BoolLiteral\") {\n      return new TypedValue(\"bool\", node.value === \"true\");\n    }\n\n    if (node.type === \"BinaryExpression\") {\n      const left = await this.evaluateNode(node.left);\n      const right = await this.evaluateNode(node.right);\n\n      // String concatenation\n      if (\n        (left.type === \"string\" || right.type === \"string\") &&\n        node.operator === \"PLUS\"\n      ) {\n        return new TypedValue(\n          \"string\",\n          left.value.toString() + right.value.toString()\n        );\n      }\n\n      // TODO Additionally check that the type is signed if subtracting\n      if (!types.isInteger(left.type) || !types.isInteger(right.type)) {\n        this.panic(\n          `Cannot evaluate binary expression \"${\n            node.operator\n          }\" for non-integer types \"${left.type}\" and \"${right.type}\"`\n        );\n      }\n\n      switch (node.operator) {\n        case \"PLUS\":\n          return new TypedValue(\"int256\", left.value.add(right.value));\n        case \"MINUS\":\n          return new TypedValue(\"int256\", left.value.sub(right.value));\n        case \"STAR\":\n          return new TypedValue(\"int256\", left.value.mul(right.value));\n        case \"POWER\":\n          return new TypedValue(\"int256\", left.value.pow(right.value));\n        case \"SLASH\":\n          return new TypedValue(\"int256\", left.value.div(right.value));\n        case \"MODULO\":\n          return new TypedValue(\"int256\", left.value.mod(right.value));\n        default:\n          this.panic(`Undefined binary operator \"${node.operator}\"`);\n      }\n    }\n\n    if (node.type === \"ComparisonExpression\") {\n      const left = await this.evaluateNode(node.left);\n      const right = await this.evaluateNode(node.right);\n\n      let leftValue = left.value;\n      let rightValue = right.value;\n\n      const bothTypesAddress = (left, right) =>\n        // isAddress is true if type is address or bytes with size less than 20\n        types.isAddress(left.type) && types.isAddress(right.type);\n\n      const bothTypesBytes = (left, right) =>\n        types.types.bytes.isType(left.type) &&\n        types.types.bytes.isType(right.type);\n\n      // Conversion to BN for comparison will happen if:\n      // - Both types are addresses or bytes of any size (can be different sizes)\n      // - If one of the types is an address and the other bytes with size less than 20\n      if (bothTypesAddress(left, right) || bothTypesBytes(left, right)) {\n        leftValue = Web3Utils.toBN(leftValue);\n        rightValue = Web3Utils.toBN(rightValue);\n      } else if (!types.isInteger(left.type) || !types.isInteger(right.type)) {\n        this.panic(\n          `Cannot evaluate binary expression \"${\n            node.operator\n          }\" for non-integer or fixed-size bytes types \"${left.type}\" and \"${\n            right.type\n          }\"`\n        );\n      }\n\n      switch (node.operator) {\n        case \"GREATER\":\n          return new TypedValue(\"bool\", leftValue.gt(rightValue));\n        case \"GREATER_EQUAL\":\n          return new TypedValue(\"bool\", leftValue.gte(rightValue));\n        case \"LESS\":\n          return new TypedValue(\"bool\", leftValue.lt(rightValue));\n        case \"LESS_EQUAL\":\n          return new TypedValue(\"bool\", leftValue.lte(rightValue));\n        case \"EQUAL_EQUAL\":\n          return new TypedValue(\"bool\", leftValue.eq(rightValue));\n        case \"BANG_EQUAL\":\n          return new TypedValue(\"bool\", !leftValue.eq(rightValue));\n      }\n    }\n\n    if (node.type === \"TernaryExpression\") {\n      if ((await this.evaluateNode(node.predicate)).value) {\n        return this.evaluateNode(node.left);\n      }\n\n      return this.evaluateNode(node.right);\n    }\n\n    if (node.type === \"DefaultExpression\") {\n      const left = await this.evaluateNode(node.left);\n      let leftFalsey;\n\n      if (types.isInteger(left.type)) {\n        leftFalsey = left.value.isZero();\n      } else if (left.type === \"address\" || left.type.startsWith(\"bytes\")) {\n        leftFalsey = /^0x[0]*$/.test(left.value);\n      } else {\n        leftFalsey = !left.value;\n      }\n\n      return leftFalsey ? this.evaluateNode(node.right) : left;\n    }\n\n    if (node.type === \"CallExpression\") {\n      // TODO Add a check for number of return values (can only be 1 for now)\n      let target;\n\n      // Inject self\n      if (node.target.type === \"Identifier\" && node.target.value === \"self\") {\n        target = this.to;\n      } else {\n        target = await this.evaluateNode(node.target);\n      }\n\n      if (target.type !== \"bytes20\" && target.type !== \"address\") {\n        this.panic(\"Target of call expression was not an address\");\n      } else if (!Web3Utils.checkAddressChecksum(target.value)) {\n        this.panic(`Checksum failed for address \"${target.value}\"`);\n      }\n\n      const inputs = await this.evaluateNodes(node.inputs);\n      const outputs = node.outputs;\n\n      const call = ABI.encodeFunctionCall(\n        {\n          name: node.callee,\n          type: \"function\",\n\n          inputs,\n          outputs\n        },\n        inputs.map(input => input.value)\n      );\n\n      const returnType = outputs[0].type;\n      return this.eth\n        .call({\n          to: target.value,\n          data: call\n        })\n        .then(\n          data =>\n            new TypedValue(returnType, ABI.decodeParameter(returnType, data))\n        );\n    }\n\n    if (node.type === \"HelperFunction\") {\n      const helperName = node.name;\n\n      if (!this.helpers.exists(helperName)) {\n        this.panic(`${helperName} helper function is not defined`);\n      }\n\n      const inputs = await this.evaluateNodes(node.inputs);\n      const result = await this.helpers.execute(helperName, inputs, {\n        eth: this.eth,\n        evaluator: this\n      });\n\n      return new TypedValue(result.type, result.value);\n    }\n\n    if (node.type === \"Identifier\") {\n      if (node.value === \"self\") {\n        return this.to;\n      }\n\n      if (!this.bindings.hasOwnProperty(node.value)) {\n        this.panic(`Undefined binding \"${node.value}\"`);\n      }\n\n      const binding = this.bindings[node.value];\n      return new TypedValue(binding.type, binding.value);\n    }\n  }\n\n  /**\n   * Evaluate the entire AST.\n   *\n   * @return {*}\n   */\n  async evaluate() {\n    const evaluatedNodes = await this.evaluateNodes(this.ast.body);\n\n    if (this.returnType === \"object\") {\n      return evaluatedNodes;\n    }\n\n    return evaluatedNodes.join(\"\");\n  }\n\n  /**\n   * Report an error and abort evaluation.\n   *\n   * @param  {string} msg\n   */\n  panic(msg) {\n    throw new Error(`Error: ${msg}`);\n  }\n}\n\n/**\n * Evaluates an AST\n *\n * @memberof radspec/evaluator\n * @param {radspec/parser/AST} ast The AST to evaluate\n * @param {radspec/Bindings} bindings An object of bindings and their values\n * @param {?Object} options An options object\n * @param {?string} options.ethNode The URL to an Ethereum node\n * @param {?string} options.to The destination address for this expression's transaction\n * @return {string}\n */\nexport function evaluate(ast, bindings, options) {\n  return new Evaluator(ast, bindings, options).evaluate();\n}\n"],"file":"index.js"}