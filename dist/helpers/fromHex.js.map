{"version":3,"sources":["../../src/helpers/fromHex.js"],"names":["isHexStrict","hex","test","hexToAscii","Error","str","i","l","length","substring","code","parseInt","substr","String","fromCharCode","to","type","value","ethers","utils","toUtf8String","bigNumberify","toString"],"mappings":";;;;;;;AAAA;;AAEA,MAAMA,WAAW,GAAGC,GAAG,IAAI;AACzB,SACE,CAAC,OAAOA,GAAP,KAAe,QAAf,IAA2B,OAAOA,GAAP,KAAe,QAA3C,KACA,qBAAqBC,IAArB,CAA0BD,GAA1B,CAFF;AAID,CALD;;AAOA,MAAME,UAAU,GAAGF,GAAG,IAAI;AACxB,MAAI,CAACD,WAAW,CAACC,GAAD,CAAhB,EAAuB;AACrB,UAAM,IAAIG,KAAJ,CAAU,2CAAV,CAAN;AACD;;AAED,MAAIC,GAAG,GAAG,EAAV;AAEA,MAAIC,CAAC,GAAG,CAAR;AACA,QAAMC,CAAC,GAAGN,GAAG,CAACO,MAAd;;AAEA,MAAIP,GAAG,CAACQ,SAAJ,CAAc,CAAd,EAAiB,CAAjB,MAAwB,IAA5B,EAAkC;AAChCH,IAAAA,CAAC,GAAG,CAAJ;AACD;;AACD,SAAOA,CAAC,GAAGC,CAAX,EAAcD,CAAC,IAAI,CAAnB,EAAsB;AACpB,UAAMI,IAAI,GAAGC,QAAQ,CAACV,GAAG,CAACW,MAAJ,CAAWN,CAAX,EAAc,CAAd,CAAD,EAAmB,EAAnB,CAArB;AACAD,IAAAA,GAAG,IAAIQ,MAAM,CAACC,YAAP,CAAoBJ,IAApB,CAAP;AACD;;AAED,SAAOL,GAAP;AACD,CAnBD;;eAqBe;AACb;;;;;;;AAOA,CAACJ,GAAD,EAAMc,EAAE,GAAG,MAAX,KAAsB;AACpB,MAAIA,EAAE,KAAK,MAAX,EAAmB;AACjB,WAAO;AACLC,MAAAA,IAAI,EAAE,QADD;AAELC,MAAAA,KAAK,EAAEC,eAAOC,KAAP,CAAaC,YAAb,CAA0BnB,GAA1B;AAFF,KAAP;AAID;;AAED,MAAIc,EAAE,KAAK,QAAP,IAAmBA,EAAE,KAAK,SAA9B,EAAyC;AACvC,WAAO;AACLC,MAAAA,IAAI,EAAE,QADD;AAELC,MAAAA,KAAK,EAAEC,eAAOC,KAAP,CAAaE,YAAb,CAA0BpB,GAA1B,EAA+BqB,QAA/B;AAFF,KAAP;AAID;;AAED,MAAIP,EAAE,KAAK,OAAX,EAAoB;AAClB,WAAO;AACLC,MAAAA,IAAI,EAAE,QADD;AAELC,MAAAA,KAAK,EAAEd,UAAU,CAACF,GAAD;AAFZ,KAAP;AAID;;AAED,SAAO;AACLe,IAAAA,IAAI,EAAE,QADD;AAELC,IAAAA,KAAK,EAAEhB;AAFF,GAAP;AAID,C;;;AAEHiB,eAAOC,KAAP,CAAaJ,EAAb","sourcesContent":["import { ethers } from 'ethers';\n\nconst isHexStrict = hex => {\n  return (\n    (typeof hex === 'number' || typeof hex === 'string') &&\n    /^(-)?0x[0-9a-f]*$/i.test(hex)\n  );\n};\n\nconst hexToAscii = hex => {\n  if (!isHexStrict(hex)) {\n    throw new Error('The parameter must be a valid HEX string.');\n  }\n\n  let str = '';\n\n  let i = 0;\n  const l = hex.length;\n\n  if (hex.substring(0, 2) === '0x') {\n    i = 2;\n  }\n  for (; i < l; i += 2) {\n    const code = parseInt(hex.substr(i, 2), 16);\n    str += String.fromCharCode(code);\n  }\n\n  return str;\n};\n\nexport default () =>\n  /**\n   * Returns the string representation of a given hex value\n   *\n   * @param {string} hex The hex string\n   * @param {string} [to='utf8'] The type to convert the hex from (supported types: 'utf8', 'number', 'decimal')\n   * @return {radspec/evaluator/TypedValue}\n   */\n  (hex, to = 'utf8') => {\n    if (to === 'utf8') {\n      return {\n        type: 'string',\n        value: ethers.utils.toUtf8String(hex),\n      };\n    }\n\n    if (to === 'number' || to === 'decimal') {\n      return {\n        type: 'string',\n        value: ethers.utils.bigNumberify(hex).toString(),\n      };\n    }\n\n    if (to === 'ascii') {\n      return {\n        type: 'string',\n        value: hexToAscii(hex),\n      };\n    }\n\n    return {\n      type: 'string',\n      value: hex,\n    };\n  };\n\nethers.utils.to;\n"],"file":"fromHex.js"}