{"version":3,"sources":["../../src/helpers/radspec.js"],"names":["makeUnknownFunctionNode","methodId","type","value","getSig","fn","substr","processFunctions","functions","Object","keys","reduce","acc","key","source","sig","eth","evaluator","addr","data","knownFunctions","length","registry","MethodRegistry","networkId","result","lookup","name","parse","inputString","replace","split","parameters","inputs","parameterValues","ABI","decodeParameters","input","i","availableHelpers","helpers","getHelpers","to"],"mappings":"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","sourcesContent":["import ABI from 'web3-eth-abi'\nimport { keccak256 } from 'web3-utils'\nimport MethodRegistry from './lib/methodRegistry'\nimport { evaluateRaw } from '../lib/'\nimport knownFunctions from '../data/knownFunctions'\n\nconst makeUnknownFunctionNode = (methodId) => ({\n  type: 'string',\n  value: `Unknown function (${methodId})`\n})\n\nconst getSig = (fn) =>\n  keccak256(fn).substr(0, 10)\n\n// Convert from the knownFunctions data format into the needed format\n// Input: { \"signature(type1,type2)\": \"Its radspec string\", ... }\n// Output: { \"0xabcdef12\": { \"sig\": \"signature(type1,type2)\", \"source\": \"Its radspec string\" }, ...}\nconst processFunctions = (functions) => (\n  Object.keys(functions).reduce(\n    (acc, key) => (\n      {\n        [getSig(key)]: { source: functions[key], sig: key },\n        ...acc\n      }\n    ), {})\n)\nexport default (eth, evaluator) =>\n  /**\n   * Interpret calldata using radspec recursively. If the function signature is not in the package's known\n   * functions, it fallbacks to looking for the function name using github.com/parity-contracts/signature-registry\n   *\n   * @param {address} addr The target address of the call\n   * @param {bytes} data The calldata of the call\n   * @return {Promise<radspec/evaluator/TypedValue>}\n   */\n  async (addr, data) => {\n    const functions = processFunctions(knownFunctions)\n\n    if (data.length < 10) {\n      return makeUnknownFunctionNode(data)\n    }\n\n    // Get method ID\n    const methodId = data.substr(0, 10)\n    const fn = functions[methodId]\n\n    // If function is not a known function, execute fallback checking Parity's on-chain signature registry\n    if (!fn) {\n      // Even if we pass the ETH object, if it is not on mainnet it will use Aragon's ETH mainnet node\n      // As the registry is the only available on mainnet\n      const registry = new MethodRegistry({ networkId: '1', eth })\n      const result = await registry.lookup(methodId)\n\n      if (result) {\n        const { name } = registry.parse(result)\n        return {\n          type: 'string',\n          value: name // TODO: should we decode and print the arguments as well?\n        }\n      } else {\n        return makeUnknownFunctionNode(methodId)\n      }\n    }\n    // If the function was found in local radspec registry. Decode and evaluate.\n    const { source, sig } = fn\n\n    // get the array of input types from the function signature\n    const inputString = sig.replace(')', '').split('(')[1]\n\n    let parameters = []\n\n    // If the function has parameters\n    if (inputString !== '') {\n      const inputs = inputString.split(',')\n\n      // Decode parameters\n      const parameterValues = ABI.decodeParameters(inputs, '0x' + data.substr(10))\n      parameters = inputs.reduce((acc, input, i) => (\n        {\n          [`$${i + 1}`]: {\n            type: input,\n            value: parameterValues[i]\n          },\n          ...acc\n        }), {})\n    }\n\n    return {\n      type: 'string',\n      value: await evaluateRaw(\n        source,\n        parameters,\n        {\n          eth,\n          availableHelpers: evaluator.helpers.getHelpers(),\n          to: addr\n        }\n      )\n    }\n  }\n"],"file":"radspec.js"}