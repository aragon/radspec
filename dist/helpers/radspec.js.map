{"version":3,"sources":["../../src/helpers/radspec.js"],"names":["makeUnknownFunctionNode","methodId","type","value","getSig","fnStr","ethers","utils","keccak256","toUtf8Bytes","substr","processFunctions","functions","Object","keys","reduce","acc","key","source","sig","provider","evaluator","addr","data","knownFunctions","length","fn","registry","MethodRegistry","networkId","result","lookup","name","parse","inputString","replace","split","parameters","inputs","parameterValues","abiCoder","decodeParameters","input","i","availableHelpers","helpers","getHelpers","to"],"mappings":"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","sourcesContent":["import { ethers } from 'ethers';\nimport MethodRegistry from './lib/methodRegistry';\nimport { evaluateRaw } from '../lib/';\nimport knownFunctions from '../data/knownFunctions';\nimport { abiCoder } from '../defaults';\n\nconst makeUnknownFunctionNode = methodId => ({\n  type: 'string',\n  value: `Unknown function (${methodId})`,\n});\n\nconst getSig = fnStr =>\n  ethers.utils.keccak256(ethers.utils.toUtf8Bytes(fnStr)).substr(0, 10);\n\n// Convert from the knownFunctions data format into the needed format\n// Input: { \"signature(type1,type2)\": \"Its radspec string\", ... }\n// Output: { \"0xabcdef12\": { \"sig\": \"signature(type1,type2)\", \"source\": \"Its radspec string\" }, ...}\nconst processFunctions = functions =>\n  Object.keys(functions).reduce(\n      (acc, key) => ({\n        [getSig(key)]: { source: functions[key], sig: key },\n        ...acc,\n      }),\n      {}\n  );\nexport default (provider, evaluator) =>\n  /**\n   * Interpret calldata using radspec recursively. If the function signature is not in the package's known\n   * functions, it fallbacks to looking for the function name using github.com/parity-contracts/signature-registry\n   *\n   * @param {address} addr The target address of the call\n   * @param {bytes} data The calldata of the call\n   * @return {Promise<radspec/evaluator/TypedValue>}\n   */\n  async (addr, data) => {\n    const functions = processFunctions(knownFunctions);\n\n    if (data.length < 10) {\n      return makeUnknownFunctionNode(data);\n    }\n\n    // Get method ID\n    const methodId = data.substr(0, 10);\n    const fn = functions[methodId];\n\n    // If function is not a known function, execute fallback checking Parity's on-chain signature registry\n    if (!fn) {\n      // Even if we pass the ETH object, if it is not on mainnet it will use Aragon's ETH mainnet node\n      // As the registry is the only available on mainnet\n      const registry = new MethodRegistry({ networkId: '1', provider });\n      const result = await registry.lookup(methodId);\n\n      if (result) {\n        const { name } = registry.parse(result);\n        return {\n          type: 'string',\n          value: name, // TODO: should we decode and print the arguments as well?\n        };\n      } else {\n        return makeUnknownFunctionNode(methodId);\n      }\n    }\n    // If the function was found in local radspec registry. Decode and evaluate.\n    const { source, sig } = fn;\n\n    // get the array of input types from the function signature\n    const inputString = sig.replace(')', '').split('(')[1];\n\n    let parameters = [];\n\n    // If the function has parameters\n    if (inputString !== '') {\n      const inputs = inputString.split(',');\n\n      // Decode parameters\n      const parameterValues = abiCoder.decodeParameters(\n          inputs,\n          '0x' + data.substr(10)\n      );\n\n      parameters = inputs.reduce(\n          (acc, input, i) => ({\n            [`$${i + 1}`]: {\n              type: input,\n              value: parameterValues[i],\n            },\n            ...acc,\n          }),\n          {}\n      );\n    }\n\n    return {\n      type: 'string',\n      value: await evaluateRaw(source, parameters, {\n        availableHelpers: evaluator.helpers.getHelpers(),\n        provider,\n        to: addr,\n      }),\n    };\n  };\n"],"file":"radspec.js"}