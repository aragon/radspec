{"version":3,"sources":["../../../src/helpers/lib/methodRegistry.js"],"names":["REGISTRY_LOOKUP_ABI","constant","inputs","name","type","outputs","payable","REGISTRY_MAP","MethodRegistry","constructor","provider","networkId","ethers","providers","JsonRpcProvider","DEFAULT_ETH_NODE","initRegistry","getNetwork","chainId","address","Error","registry","Contract","lookup","sigBytes","functions","entries","parse","signature","match","charAt","toUpperCase","slice","split","join","args","map","arg"],"mappings":";;;;;;;AAEA;;AACA;;AAHA;;AAKA;AACA,MAAMA,mBAAmB,GAAG,CAC1B;AACEC,EAAAA,QAAQ,EAAE,IADZ;AAEEC,EAAAA,MAAM,EAAE,CACN;AACEC,IAAAA,IAAI,EAAE,EADR;AAEEC,IAAAA,IAAI,EAAE;AAFR,GADM,CAFV;AAQED,EAAAA,IAAI,EAAE,SARR;AASEE,EAAAA,OAAO,EAAE,CACP;AACEF,IAAAA,IAAI,EAAE,EADR;AAEEC,IAAAA,IAAI,EAAE;AAFR,GADO,CATX;AAeEE,EAAAA,OAAO,EAAE,KAfX;AAgBEF,EAAAA,IAAI,EAAE;AAhBR,CAD0B,CAA5B,C,CAqBA;;AACA,MAAMG,YAAY,GAAG;AACnB,KAAG;AADgB,CAArB;;AAIe,MAAMC,cAAN,CAAqB;AAClCC,EAAAA,WAAW,CAAC;AAAEC,IAAAA,QAAF;AAAYC,IAAAA;AAAZ,MAA0B,EAA3B,EAA+B;AACxC,SAAKA,SAAL,GAAiBA,SAAS,IAAI,CAA9B;AAEA,SAAKD,QAAL,GACEA,QAAQ,IACR,IAAIE,eAAOC,SAAP,CAAiBC,eAArB,CAAqCC,0BAArC,EAAuD,KAAKJ,SAA5D,CAFF;AAGD;;AAED,QAAMK,YAAN,GAAqB;AACnB,QAAI,CAAC,MAAM,KAAKN,QAAL,CAAcO,UAAd,EAAP,EAAmCC,OAAnC,KAA+C,CAAnD,EAAsD;AACpD,WAAKR,QAAL,GAAgB,IAAIE,eAAOC,SAAP,CAAiBC,eAArB,CAAqCC,0BAArC,EAAuD,CAAvD,CAAhB;AACD;;AAED,UAAMI,OAAO,GAAGZ,YAAY,CAAC,KAAKI,SAAN,CAA5B;;AAEA,QAAI,CAACQ,OAAL,EAAc;AACZ,YAAM,IAAIC,KAAJ,CAAU,oDAAV,CAAN;AACD;;AAED,SAAKC,QAAL,GAAgB,IAAIT,eAAOU,QAAX,CACZH,OADY,EAEZnB,mBAFY,EAGZ,KAAKU,QAHO,CAAhB;AAKD;;AAED,QAAMa,MAAN,CAAaC,QAAb,EAAuB;AACrB,QAAI,CAAC,KAAKH,QAAV,EAAoB;AAClB,YAAM,KAAKL,YAAL,EAAN;AACD;;AAED,WAAO,KAAKK,QAAL,CAAcI,SAAd,CAAwBC,OAAxB,CAAgCF,QAAhC,CAAP;AACD;;AAEDG,EAAAA,KAAK,CAACC,SAAD,EAAY;AACf;AACA,QAAIzB,IAAI,GAAGyB,SAAS,CAACC,KAAV,CAAgB,WAAhB,EAA6B,CAA7B,CAAX;AACA1B,IAAAA,IAAI,GACFA,IAAI,CAAC2B,MAAL,CAAY,CAAZ,EAAeC,WAAf,KACA5B,IAAI,CACC6B,KADL,CACW,CADX,EAEKC,KAFL,CAEW,WAFX,EAGKC,IAHL,CAGU,GAHV,CAFF;AAOA,UAAMC,IAAI,GAAGP,SAAS,CACjBC,KADQ,CACF,QADE,EACQ,CADR,EAERG,KAFQ,CAEF,CAFE,EAEC,CAAC,CAFF,EAGRC,KAHQ,CAGF,GAHE,CAAb;AAKA,WAAO;AACL9B,MAAAA,IADK;AAELgC,MAAAA,IAAI,EAAEA,IAAI,CAACC,GAAL,CAASC,GAAG,IAAI;AACpB,eAAO;AAAEjC,UAAAA,IAAI,EAAEiC;AAAR,SAAP;AACD,OAFK;AAFD,KAAP;AAMD;;AAxDiC","sourcesContent":["// From: https://github.com/danfinlay/eth-method-registry\n\nimport { ethers } from 'ethers';\nimport { DEFAULT_ETH_NODE } from '../../defaults';\n\n/* eslint-disable key-spacing, quotes */\nconst REGISTRY_LOOKUP_ABI = [\n  {\n    constant: true,\n    inputs: [\n      {\n        name: '',\n        type: 'bytes4',\n      },\n    ],\n    name: 'entries',\n    outputs: [\n      {\n        name: '',\n        type: 'string',\n      },\n    ],\n    payable: false,\n    type: 'function',\n  },\n];\n\n// networkId -> registry address\nconst REGISTRY_MAP = {\n  1: '0x44691B39d1a75dC4E0A0346CBB15E310e6ED1E86',\n};\n\nexport default class MethodRegistry {\n  constructor({ provider, networkId } = {}) {\n    this.networkId = networkId || 1;\n\n    this.provider =\n      provider ||\n      new ethers.providers.JsonRpcProvider(DEFAULT_ETH_NODE, this.networkId);\n  }\n\n  async initRegistry() {\n    if ((await this.provider.getNetwork()).chainId !== 1) {\n      this.provider = new ethers.providers.JsonRpcProvider(DEFAULT_ETH_NODE, 1);\n    }\n\n    const address = REGISTRY_MAP[this.networkId];\n\n    if (!address) {\n      throw new Error('No method registry found on the requested network.');\n    }\n\n    this.registry = new ethers.Contract(\n        address,\n        REGISTRY_LOOKUP_ABI,\n        this.provider\n    );\n  }\n\n  async lookup(sigBytes) {\n    if (!this.registry) {\n      await this.initRegistry();\n    }\n\n    return this.registry.functions.entries(sigBytes);\n  }\n\n  parse(signature) {\n    // TODO: Throw if there are unknown types in the signature or there if is any chars after the closing parenthesis\n    let name = signature.match(/^.+(?=\\()/)[0];\n    name =\n      name.charAt(0).toUpperCase() +\n      name\n          .slice(1)\n          .split(/(?=[A-Z])/)\n          .join(' ');\n\n    const args = signature\n        .match(/\\(.+\\)/)[0]\n        .slice(1, -1)\n        .split(',');\n\n    return {\n      name,\n      args: args.map(arg => {\n        return { type: arg };\n      }),\n    };\n  }\n}\n"],"file":"methodRegistry.js"}