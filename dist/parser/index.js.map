{"version":3,"sources":["../../src/parser/index.js"],"names":["PARSER_STATE","OK","ERROR","Parser","constructor","tokens","state","cursor","consume","previous","peek","matches","expected","eof","type","comparison","astBody","node","addition","operator","right","left","predicate","report","multiplication","power","unary","identifier","value","previousNode","length","pop","property","target","callee","inputs","functionInputs","outputs","push","helper","name","primary","NUMBER","STRING","HEXADECIMAL","BOOLEAN","expression","body","input","castType","walk","token","parse","ast","console","error"],"mappings":";;;;;;;;AAAA;;;;AAIA;;;;;;;AAOA;;;;;;AAKA;;;;;;;AAOA;;;;;;AAMA,MAAMA,YAAY,GAAG;AACnBC,EAAAA,EAAE,EAAE,IADe;AAEnBC,EAAAA,KAAK,EAAE;AAFY,CAArB;AAKA;;;;;;;;;;AASO,MAAMC,MAAN,CAAa;AAClBC,EAAAA,WAAW,CAACC,MAAD,EAAS;AAClB,SAAKC,KAAL,GAAaN,YAAY,CAACC,EAA1B;AAEA,SAAKI,MAAL,GAAcA,MAAd;AACA,SAAKE,MAAL,GAAc,CAAd;AACD;AAED;;;;;;;AAKAC,EAAAA,OAAO,GAAG;AACR,SAAKD,MAAL;AAEA,WAAO,KAAKF,MAAL,CAAY,KAAKE,MAAL,GAAc,CAA1B,CAAP;AACD;AAED;;;;;;;AAKAE,EAAAA,QAAQ,GAAG;AACT,WAAO,KAAKJ,MAAL,CAAY,KAAKE,MAAL,GAAc,CAA1B,CAAP;AACD;AAED;;;;;;;AAKAG,EAAAA,IAAI,GAAG;AACL,WAAO,KAAKL,MAAL,CAAY,KAAKE,MAAjB,CAAP;AACD;AAED;;;;;;;;;;AAQAI,EAAAA,OAAO,CAAC,GAAGC,QAAJ,EAAc;AACnB,QAAI,KAAKC,GAAL,EAAJ,EAAgB,OAAO,KAAP;;AAChB,SAAK,MAAMC,IAAX,IAAmBF,QAAnB,EAA6B;AAC3B,UAAI,KAAKF,IAAL,GAAYI,IAAZ,KAAqBA,IAAzB,EAA+B;AAC7B,aAAKP,MAAL;AACA,eAAO,IAAP;AACD;AACF;;AAED,WAAO,KAAP;AACD;AAED;;;;;;;;AAMAQ,EAAAA,UAAU,CAACC,OAAD,EAAU;AAClB,QAAIC,IAAI,GAAG,KAAKC,QAAL,CAAcF,OAAd,CAAX;;AAEA,WACE,KAAKL,OAAL,CACI,SADJ,EAEI,eAFJ,EAGI,MAHJ,EAII,YAJJ,EAKI,aALJ,EAMI,YANJ,CADF,EASE;AACA,YAAMQ,QAAQ,GAAG,KAAKV,QAAL,GAAgBK,IAAjC;AACA,YAAMM,KAAK,GAAG,KAAKF,QAAL,CAAcF,OAAd,CAAd;AACAC,MAAAA,IAAI,GAAG;AACLH,QAAAA,IAAI,EAAE,sBADD;AAELK,QAAAA,QAFK;AAGLE,QAAAA,IAAI,EAAEJ,IAHD;AAILG,QAAAA;AAJK,OAAP;AAMD;;AAED,QAAI,KAAKT,OAAL,CAAa,eAAb,CAAJ,EAAmC;AACjCM,MAAAA,IAAI,GAAG;AACLH,QAAAA,IAAI,EAAE,mBADD;AAELQ,QAAAA,SAAS,EAAEL,IAFN;AAGLI,QAAAA,IAAI,EAAE,KAAKN,UAAL,CAAgBC,OAAhB;AAHD,OAAP;;AAMA,UAAI,CAAC,KAAKL,OAAL,CAAa,OAAb,CAAL,EAA4B;AAC1B,aAAKY,MAAL,CAAY,qCAAZ;AACD;;AAEDN,MAAAA,IAAI,CAACG,KAAL,GAAa,KAAKL,UAAL,CAAgBC,OAAhB,CAAb;AACD;;AAED,QAAI,KAAKL,OAAL,CAAa,qBAAb,CAAJ,EAAyC;AACvCM,MAAAA,IAAI,GAAG;AACLI,QAAAA,IAAI,EAAEJ,IADD;AAELG,QAAAA,KAAK,EAAE,KAAKL,UAAL,EAFF;AAGLD,QAAAA,IAAI,EAAE;AAHD,OAAP;AAKD;;AAED,WAAOG,IAAP;AACD;AAED;;;;;;;;AAMAC,EAAAA,QAAQ,CAACF,OAAD,EAAU;AAChB,QAAIC,IAAI,GAAG,KAAKO,cAAL,CAAoBR,OAApB,CAAX;;AAEA,WAAO,KAAKL,OAAL,CAAa,OAAb,EAAsB,MAAtB,CAAP,EAAsC;AACpC,YAAMQ,QAAQ,GAAG,KAAKV,QAAL,GAAgBK,IAAjC;AACA,YAAMM,KAAK,GAAG,KAAKI,cAAL,CAAoBR,OAApB,CAAd;AACAC,MAAAA,IAAI,GAAG;AACLH,QAAAA,IAAI,EAAE,kBADD;AAELK,QAAAA,QAFK;AAGLE,QAAAA,IAAI,EAAEJ,IAHD;AAILG,QAAAA;AAJK,OAAP;AAMD;;AAED,WAAOH,IAAP;AACD;AAED;;;;;;;;AAMAO,EAAAA,cAAc,CAACR,OAAD,EAAU;AACtB,QAAIC,IAAI,GAAG,KAAKQ,KAAL,CAAWT,OAAX,CAAX;;AAEA,WAAO,KAAKL,OAAL,CAAa,OAAb,EAAsB,MAAtB,EAA8B,QAA9B,CAAP,EAAgD;AAC9C,YAAMQ,QAAQ,GAAG,KAAKV,QAAL,GAAgBK,IAAjC;AACA,YAAMM,KAAK,GAAG,KAAKK,KAAL,CAAWT,OAAX,CAAd;AAEAC,MAAAA,IAAI,GAAG;AACLH,QAAAA,IAAI,EAAE,kBADD;AAELK,QAAAA,QAFK;AAGLE,QAAAA,IAAI,EAAEJ,IAHD;AAILG,QAAAA;AAJK,OAAP;AAMD;;AAED,WAAOH,IAAP;AACD;AAED;;;;;;;;AAMAQ,EAAAA,KAAK,CAACT,OAAD,EAAU;AACb,QAAIC,IAAI,GAAG,KAAKS,KAAL,CAAWV,OAAX,CAAX;;AAEA,WAAO,KAAKL,OAAL,CAAa,OAAb,CAAP,EAA8B;AAC5B,YAAMQ,QAAQ,GAAG,KAAKV,QAAL,GAAgBK,IAAjC;AACA,YAAMM,KAAK,GAAG,KAAKM,KAAL,CAAWV,OAAX,CAAd;AAEAC,MAAAA,IAAI,GAAG;AACLH,QAAAA,IAAI,EAAE,kBADD;AAELK,QAAAA,QAFK;AAGLE,QAAAA,IAAI,EAAEJ,IAHD;AAILG,QAAAA;AAJK,OAAP;AAMD;;AAED,WAAOH,IAAP;AACD;AAED;;;;;;;;AAMAS,EAAAA,KAAK,CAACV,OAAD,EAAU;AACb,QAAI,KAAKL,OAAL,CAAa,MAAb,EAAqB,OAArB,CAAJ,EAAmC;AACjC,YAAMQ,QAAQ,GAAG,KAAKV,QAAL,GAAgBK,IAAjC;AACA,YAAMM,KAAK,GAAG,KAAKM,KAAL,CAAWV,OAAX,CAAd;AAEA,aAAO;AACLF,QAAAA,IAAI,EAAE,iBADD;AAELK,QAAAA,QAFK;AAGLC,QAAAA,KAAK,EAAEA;AAHF,OAAP;AAKD;;AAED,WAAO,KAAKO,UAAL,CAAgBX,OAAhB,CAAP;AACD;AAED;;;;;;;;AAMAW,EAAAA,UAAU,CAACX,OAAD,EAAU;AAClB,QAAIC,IAAJ;;AAEA,QAAI,KAAKN,OAAL,CAAa,YAAb,CAAJ,EAAgC;AAC9BM,MAAAA,IAAI,GAAG;AACLH,QAAAA,IAAI,EAAE,YADD;AAELc,QAAAA,KAAK,EAAE,KAAKnB,QAAL,GAAgBmB;AAFlB,OAAP;AAID;;AAED,QAAI,CAACX,IAAL,EAAW;AACT,YAAMY,YAAY,GAAGb,OAAO,CAACc,MAAR,IAAkBd,OAAO,CAACA,OAAO,CAACc,MAAR,GAAiB,CAAlB,CAA9C;;AACA,UACED,YAAY,KACXA,YAAY,CAACf,IAAb,KAAsB,YAAtB,IACCe,YAAY,CAACf,IAAb,KAAsB,mBADvB,IAECe,YAAY,CAACf,IAAb,KAAsB,gBAHZ,CADd,EAKE;AACAG,QAAAA,IAAI,GAAGY,YAAP,CADA,CAEA;;AACAb,QAAAA,OAAO,CAACe,GAAR;AACD;AACF;;AAED,QAAId,IAAJ,EAAU;AACR,aAAO,KAAKN,OAAL,CAAa,KAAb,CAAP,EAA4B;AAC1B,cAAMqB,QAAQ,GAAG,KAAKxB,OAAL,GAAeoB,KAAhC;AAEAX,QAAAA,IAAI,GAAG;AACLH,UAAAA,IAAI,EAAE,0BADD;AAELmB,UAAAA,MAAM,EAAEhB,IAFH;AAGLe,UAAAA;AAHK,SAAP;AAKD;;AAED,UAAI,KAAKrB,OAAL,CAAa,YAAb,CAAJ,EAAgC;AAC9BM,QAAAA,IAAI,GAAG;AACLH,UAAAA,IAAI,EAAE,gBADD;AAELmB,UAAAA,MAAM,EAAEhB,IAAI,CAACgB,MAFR;AAGLC,UAAAA,MAAM,EAAEjB,IAAI,CAACe,QAHR;AAILG,UAAAA,MAAM,EAAE,KAAKC,cAAL,CAAoBpB,OAApB,CAJH;AAKLqB,UAAAA,OAAO,EAAE;AALJ,SAAP;;AAQA,YAAI,KAAKxB,GAAL,EAAJ,EAAgB;AACd;AACA,eAAKU,MAAL,CAAY,8BAAZ;AACD;;AAEDN,QAAAA,IAAI,CAACoB,OAAL,CAAaC,IAAb,CAAkB;AAChBxB,UAAAA,IAAI,EAAE,KAAKA,IAAL;AADU,SAAlB;AAGD;;AAED,aAAOG,IAAP;AACD;;AAED,WAAO,KAAKsB,MAAL,CAAYvB,OAAZ,CAAP;AACD;AAED;;;;;;;;AAMAuB,EAAAA,MAAM,CAACvB,OAAD,EAAU;AACd,QAAI,KAAKL,OAAL,CAAa,IAAb,CAAJ,EAAwB;AACtB,YAAMgB,UAAU,GAAG,KAAKnB,OAAL,EAAnB;AACA,YAAMgC,IAAI,GAAGb,UAAU,CAACC,KAAxB;;AAEA,UAAID,UAAU,CAACb,IAAX,KAAoB,YAAxB,EAAsC;AACpC,aAAKS,MAAL,CAAa,iCAAgCiB,IAAK,oBAAlD;AACD;;AAED,YAAMvB,IAAI,GAAG;AACXH,QAAAA,IAAI,EAAE,gBADK;AAEX0B,QAAAA,IAAI,EAAEA;AAFK,OAAb;;AAKA,UAAI,KAAK7B,OAAL,CAAa,YAAb,CAAJ,EAAgC;AAC9BM,QAAAA,IAAI,CAACkB,MAAL,GAAc,KAAKC,cAAL,CAAoBpB,OAApB,CAAd;AACD,OAFD,MAEO,CACL;AACA;AACD;;AAED,aAAOC,IAAP;AACD;;AAED,WAAO,KAAKwB,OAAL,CAAazB,OAAb,CAAP;AACD;AAED;;;;;;;;AAMAyB,EAAAA,OAAO,CAACzB,OAAD,EAAU;AACf,QAAI,KAAKL,OAAL,CAAa,QAAb,EAAuB,QAAvB,EAAiC,aAAjC,EAAgD,SAAhD,CAAJ,EAAgE;AAC9D,YAAMG,IAAI,GAAG;AACX4B,QAAAA,MAAM,EAAE,eADG;AAEXC,QAAAA,MAAM,EAAE,eAFG;AAGXC,QAAAA,WAAW,EAAE,cAHF;AAIXC,QAAAA,OAAO,EAAE;AAJE,QAKX,KAAKpC,QAAL,GAAgBK,IALL,CAAb;AAOA,aAAO;AACLA,QAAAA,IADK;AAELc,QAAAA,KAAK,EAAE,KAAKnB,QAAL,GAAgBmB;AAFlB,OAAP;AAID;;AAED,QAAI,KAAKjB,OAAL,CAAa,YAAb,CAAJ,EAAgC;AAC9B,UAAImC,UAAJ;;AAEA,SAAG;AACD;AACAA,QAAAA,UAAU,GAAG,KAAK/B,UAAL,CAAgB+B,UAAU,GAAG,CAACA,UAAD,CAAH,GAAkB,EAA5C,CAAb;AACD,OAHD,QAGS,CAAC,KAAKjC,GAAL,EAAD,IAAe,CAAC,KAAKF,OAAL,CAAa,aAAb,CAHzB;;AAKA,UAAI,KAAKE,GAAL,EAAJ,EAAgB;AACd,aAAKU,MAAL,CAAY,uBAAZ;AACD;;AAED,aAAO;AACLT,QAAAA,IAAI,EAAE,mBADD;AAELiC,QAAAA,IAAI,EAAED;AAFD,OAAP;AAID;;AAED,SAAKvB,MAAL,CAAa,kBAAiB,KAAKf,OAAL,GAAeM,IAAK,GAAlD;AACD;AAED;;;;;;;AAKAA,EAAAA,IAAI,GAAG;AACL,QAAI,CAAC,KAAKH,OAAL,CAAa,OAAb,CAAD,IAA0B,KAAKD,IAAL,GAAYI,IAAZ,KAAqB,MAAnD,EAA2D;AACzD;AACA,WAAKS,MAAL,CAAa,yBAAwB,KAAKb,IAAL,GAAYI,IAAK,GAAtD;AACD;;AAED,WAAO,KAAKN,OAAL,GAAeoB,KAAtB;AACD;AAED;;;;;;;;AAMAQ,EAAAA,cAAc,CAACpB,OAAD,EAAU;AACtB,UAAMmB,MAAM,GAAG,EAAf;;AAEA,WAAO,CAAC,KAAKtB,GAAL,EAAD,IAAe,CAAC,KAAKF,OAAL,CAAa,aAAb,CAAvB,EAAoD;AAClD,YAAMqC,KAAK,GAAG,KAAKjC,UAAL,CAAgBC,OAAhB,CAAd;;AACA,UAAI,CAACgC,KAAK,CAAClC,IAAX,EAAiB;AACfkC,QAAAA,KAAK,CAAClC,IAAN,GAAa,KAAKA,IAAL,EAAb;AACD,OAFD,MAEO,IAAI,KAAKH,OAAL,CAAa,OAAb,CAAJ,EAA2B;AAChCqC,QAAAA,KAAK,CAACC,QAAN,GAAiB,KAAKzC,OAAL,GAAeoB,KAAhC;AACD;;AAEDO,MAAAA,MAAM,CAACG,IAAP,CAAYU,KAAZ,EARkD,CAUlD;AACA;AACA;;AACA,UAAI,CAAC,KAAKrC,OAAL,CAAa,OAAb,CAAD,IAA0B,KAAKD,IAAL,GAAYI,IAAZ,KAAqB,aAAnD,EAAkE;AACnE;;AAED,WAAOqB,MAAP;AACD;AAED;;;;;;;;;AAOAe,EAAAA,IAAI,CAAClC,OAAD,EAAU;AACZ,UAAMmC,KAAK,GAAG,KAAKzC,IAAL,EAAd;;AAEA,QAAIyC,KAAK,CAACrC,IAAN,KAAe,WAAnB,EAAgC;AAC9B,aAAO;AACLA,QAAAA,IAAI,EAAE,oBADD;AAELc,QAAAA,KAAK,EAAE,KAAKpB,OAAL,GAAeoB;AAFjB,OAAP;AAID;;AAED,QAAIuB,KAAK,CAACrC,IAAN,KAAe,MAAnB,EAA2B;AACzB,YAAMG,IAAI,GAAG;AACXH,QAAAA,IAAI,EAAE,qBADK;AAEXiC,QAAAA,IAAI,EAAE;AAFK,OAAb;AAKA,WAAKpC,OAAL,CAAa,MAAb;;AAEA,aAAO,CAAC,KAAKE,GAAL,EAAD,IAAe,KAAKH,IAAL,GAAYI,IAAZ,KAAqB,MAA3C,EAAmD;AACjDG,QAAAA,IAAI,CAAC8B,IAAL,CAAUT,IAAV,CAAe,KAAKY,IAAL,CAAUjC,IAAI,CAAC8B,IAAf,CAAf;AACD;;AAED,UAAI,KAAKlC,GAAL,EAAJ,EAAgB;AACd,aAAKU,MAAL,CAAY,yBAAZ;AACD;;AAED,WAAKZ,OAAL,CAAa,MAAb;AAEA,aAAOM,IAAP;AACD;;AAED,WAAO,KAAKF,UAAL,CAAgBC,OAAhB,CAAP;AACD;AAED;;;;;;;AAKA,QAAMoC,KAAN,GAAc;AACZ,UAAMC,GAAG,GAAG;AACVvC,MAAAA,IAAI,EAAE,SADI;AAEViC,MAAAA,IAAI,EAAE;AAFI,KAAZ;;AAKA,WAAO,CAAC,KAAKlC,GAAL,EAAR,EAAoB;AAClBwC,MAAAA,GAAG,CAACN,IAAJ,CAAST,IAAT,CAAc,KAAKY,IAAL,CAAUG,GAAG,CAACN,IAAd,CAAd;AACD;;AAED,QAAI,KAAKzC,KAAL,KAAeN,YAAY,CAACE,KAAhC,EAAuC;AACrCoD,MAAAA,OAAO,CAACC,KAAR,CAAe,yCAAf;AACA,aAAOF,GAAP;AACD;;AAED,WAAOA,GAAP;AACD;AAED;;;;;;;AAKAxC,EAAAA,GAAG,GAAG;AACJ,WAAO,KAAKN,MAAL,IAAe,KAAKF,MAAL,CAAYyB,MAAlC;AACD;AAED;;;;;;;;;AAOAP,EAAAA,MAAM,CAACgC,KAAD,EAAQ;AACZ,SAAKjD,KAAL,GAAaN,YAAY,CAACE,KAA1B;AACAoD,IAAAA,OAAO,CAACC,KAAR,CAAe,UAAS,KAAKhD,MAAO,MAAKgD,KAAM,EAA/C;AACD;;AArdiB;AAwdpB;;;;;;;;;;;AAOO,SAASH,KAAT,CAAe/C,MAAf,EAAuB;AAC5B,SAAO,IAAIF,MAAJ,CAAWE,MAAX,EAAmB+C,KAAnB,EAAP;AACD","sourcesContent":["/**\n * @module radspec/parser\n */\n\n/**\n * A token.\n * @typedef {Object} Token\n * @property {string} type The token type\n * @property {*?} value The value of the token\n */\n\n/**\n * An AST node.\n * @typedef {Object} Node\n * @property {string} type The node type\n */\n/**\n * An AST.\n * @typedef {Object} AST\n * @property {string} type\n * @property {Array<Node>} body The AST nodes\n */\n\n/**\n * Enum for parser state.\n *\n * @readonly\n * @enum {string}\n */\nconst PARSER_STATE = {\n  OK: 'OK',\n  ERROR: 'ERROR',\n};\n\n/**\n * Parses a token list into an AST.\n *\n * @class Parser\n * @param {Array<Token>} tokens\n * @property {string} state The state of the parser (`OK` or `ERROR`)\n * @property {Array<Token>} tokens\n * @property {number} cursor\n */\nexport class Parser {\n  constructor(tokens) {\n    this.state = PARSER_STATE.OK;\n\n    this.tokens = tokens;\n    this.cursor = 0;\n  }\n\n  /**\n   * Get the current token and increase the cursor by 1\n   *\n   * @return {Token}\n   */\n  consume() {\n    this.cursor++;\n\n    return this.tokens[this.cursor - 1];\n  }\n\n  /**\n   * Get the previous token.\n   *\n   * @return {Token}\n   */\n  previous() {\n    return this.tokens[this.cursor - 1];\n  }\n\n  /**\n   * Get the token under the cursor without consuming it.\n   *\n   * @return {Token}\n   */\n  peek() {\n    return this.tokens[this.cursor];\n  }\n\n  /**\n   * Checks if the type of the next token matches any of the expected types.\n   *\n   * Increases the cursor by 1 if the token matches.\n   *\n   * @param {...string} expected The expected types\n   * @return {boolean} True if the next token matches, otherwise false\n   */\n  matches(...expected) {\n    if (this.eof()) return false;\n    for (const type of expected) {\n      if (this.peek().type === type) {\n        this.cursor++;\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Try to parse comparison operators.\n   *\n   * @param  {Array<Node>} astBody Subtree of AST being walked\n   * @return {Node}\n   */\n  comparison(astBody) {\n    let node = this.addition(astBody);\n\n    while (\n      this.matches(\n          'GREATER',\n          'GREATER_EQUAL',\n          'LESS',\n          'LESS_EQUAL',\n          'EQUAL_EQUAL',\n          'BANG_EQUAL'\n      )\n    ) {\n      const operator = this.previous().type;\n      const right = this.addition(astBody);\n      node = {\n        type: 'ComparisonExpression',\n        operator,\n        left: node,\n        right,\n      };\n    }\n\n    if (this.matches('QUESTION_MARK')) {\n      node = {\n        type: 'TernaryExpression',\n        predicate: node,\n        left: this.comparison(astBody),\n      };\n\n      if (!this.matches('COLON')) {\n        this.report('Half-baked ternary (expected colon)');\n      }\n\n      node.right = this.comparison(astBody);\n    }\n\n    if (this.matches('DOUBLE_VERTICAL_BAR')) {\n      node = {\n        left: node,\n        right: this.comparison(),\n        type: 'DefaultExpression',\n      };\n    }\n\n    return node;\n  }\n\n  /**\n   * Try to parse arithmetic operators.\n   *\n   * @param  {Array<Node>} astBody Subtree of AST being walked\n   * @return {Node}\n   */\n  addition(astBody) {\n    let node = this.multiplication(astBody);\n\n    while (this.matches('MINUS', 'PLUS')) {\n      const operator = this.previous().type;\n      const right = this.multiplication(astBody);\n      node = {\n        type: 'BinaryExpression',\n        operator,\n        left: node,\n        right,\n      };\n    }\n\n    return node;\n  }\n\n  /**\n   * Try to parse binary operators.\n   *\n   * @param  {Array<Node>} astBody Subtree of AST being walked\n   * @return {Node}\n   */\n  multiplication(astBody) {\n    let node = this.power(astBody);\n\n    while (this.matches('SLASH', 'STAR', 'MODULO')) {\n      const operator = this.previous().type;\n      const right = this.power(astBody);\n\n      node = {\n        type: 'BinaryExpression',\n        operator,\n        left: node,\n        right,\n      };\n    }\n\n    return node;\n  }\n\n  /**\n   * Try to parse exponential operators.\n   *\n   * @param  {Array<Node>} astBody Subtree of AST being walked\n   * @return {Node}\n   */\n  power(astBody) {\n    let node = this.unary(astBody);\n\n    while (this.matches('POWER')) {\n      const operator = this.previous().type;\n      const right = this.unary(astBody);\n\n      node = {\n        type: 'BinaryExpression',\n        operator,\n        left: node,\n        right,\n      };\n    }\n\n    return node;\n  }\n\n  /**\n   * Try to parse unary operators.\n   *\n   * @param  {Array<Node>} astBody Subtree of AST being walked\n   * @return {Node}\n   */\n  unary(astBody) {\n    if (this.matches('BANG', 'MINUS')) {\n      const operator = this.previous().type;\n      const right = this.unary(astBody);\n\n      return {\n        type: 'UnaryExpression',\n        operator,\n        right: right,\n      };\n    }\n\n    return this.identifier(astBody);\n  }\n\n  /**\n   * Try to parse identifiers and call expressions.\n   *\n   * @param  {Array<Node>} astBody Subtree of AST being walked\n   * @return {Node}\n   */\n  identifier(astBody) {\n    let node;\n\n    if (this.matches('IDENTIFIER')) {\n      node = {\n        type: 'Identifier',\n        value: this.previous().value,\n      };\n    }\n\n    if (!node) {\n      const previousNode = astBody.length && astBody[astBody.length - 1];\n      if (\n        previousNode &&\n        (previousNode.type === 'Identifier' ||\n          previousNode.type === 'GroupedExpression' ||\n          previousNode.type === 'CallExpression')\n      ) {\n        node = previousNode;\n        // Consume the last node as part of this node\n        astBody.pop();\n      }\n    }\n\n    if (node) {\n      while (this.matches('DOT')) {\n        const property = this.consume().value;\n\n        node = {\n          type: 'PropertyAccessExpression',\n          target: node,\n          property,\n        };\n      }\n\n      if (this.matches('LEFT_PAREN')) {\n        node = {\n          type: 'CallExpression',\n          target: node.target,\n          callee: node.property,\n          inputs: this.functionInputs(astBody),\n          outputs: [],\n        };\n\n        if (this.eof()) {\n          // TODO Better error\n          this.report('Unterminated call expression');\n        }\n\n        node.outputs.push({\n          type: this.type(),\n        });\n      }\n\n      return node;\n    }\n\n    return this.helper(astBody);\n  }\n\n  /**\n   * Try to parse helper functions\n   *\n   * @param  {Array<Node>} astBody Subtree of AST being walked\n   * @return {Node}\n   */\n  helper(astBody) {\n    if (this.matches('AT')) {\n      const identifier = this.consume();\n      const name = identifier.value;\n\n      if (identifier.type !== 'IDENTIFIER') {\n        this.report(`Invalid helper function name '${name}' provided after @`);\n      }\n\n      const node = {\n        type: 'HelperFunction',\n        name: name,\n      };\n\n      if (this.matches('LEFT_PAREN')) {\n        node.inputs = this.functionInputs(astBody);\n      } else {\n        // There is actually no good reason not to allow calling a helper without ()\n        // this.report(`Expected '(' for executing helper function`)\n      }\n\n      return node;\n    }\n\n    return this.primary(astBody);\n  }\n\n  /**\n   * Try to parse primaries (literals).\n   *\n   * @param  {Array<Node>} astBody Subtree of AST being walked\n   * @return {Node}\n   */\n  primary(astBody) {\n    if (this.matches('NUMBER', 'STRING', 'HEXADECIMAL', 'BOOLEAN')) {\n      const type = {\n        NUMBER: 'NumberLiteral',\n        STRING: 'StringLiteral',\n        HEXADECIMAL: 'BytesLiteral',\n        BOOLEAN: 'BoolLiteral',\n      }[this.previous().type];\n\n      return {\n        type,\n        value: this.previous().value,\n      };\n    }\n\n    if (this.matches('LEFT_PAREN')) {\n      let expression;\n\n      do {\n        // Keep munching expressions in the context of the current expression\n        expression = this.comparison(expression ? [expression] : []);\n      } while (!this.eof() && !this.matches('RIGHT_PAREN'));\n\n      if (this.eof()) {\n        this.report('Unterminated grouping');\n      }\n\n      return {\n        type: 'GroupedExpression',\n        body: expression,\n      };\n    }\n\n    this.report(`Unknown token \"${this.consume().type}\"`);\n  }\n\n  /**\n   * Try to parse a type.\n   *\n   * @return {string} The type\n   */\n  type() {\n    if (!this.matches('COLON') && this.peek().type !== 'TYPE') {\n      // TODO Better error\n      this.report(`Expected a type, got \"${this.peek().type}\"`);\n    }\n\n    return this.consume().value;\n  }\n\n  /**\n   * Try to parse function arguments.\n   *\n   * @param  {Array<Node>} astBody Subtree of AST being walked\n   * @return {Array<Node>}\n   */\n  functionInputs(astBody) {\n    const inputs = [];\n\n    while (!this.eof() && !this.matches('RIGHT_PAREN')) {\n      const input = this.comparison(astBody);\n      if (!input.type) {\n        input.type = this.type();\n      } else if (this.matches('COLON')) {\n        input.castType = this.consume().value;\n      }\n\n      inputs.push(input);\n\n      // Break if the next character is not a comma or a right parenthesis\n      // If this is true, then we are specifying more parameters without\n      // delimiting them using comma.\n      if (!this.matches('COMMA') && this.peek().type !== 'RIGHT_PAREN') break;\n    }\n\n    return inputs;\n  }\n\n  /**\n   * Walk all possible paths and try to parse a single node\n   * from the list of tokens.\n   *\n   * @param  {Array<Node>} astBody Subtree of AST being walked\n   * @return {Node}\n   */\n  walk(astBody) {\n    const token = this.peek();\n\n    if (token.type === 'MONOLOGUE') {\n      return {\n        type: 'MonologueStatement',\n        value: this.consume().value,\n      };\n    }\n\n    if (token.type === 'TICK') {\n      const node = {\n        type: 'ExpressionStatement',\n        body: [],\n      };\n\n      this.matches('TICK');\n\n      while (!this.eof() && this.peek().type !== 'TICK') {\n        node.body.push(this.walk(node.body));\n      }\n\n      if (this.eof()) {\n        this.report('Unterminated expression');\n      }\n\n      this.matches('TICK');\n\n      return node;\n    }\n\n    return this.comparison(astBody);\n  }\n\n  /**\n   * Walks the token list and returns an AST.\n   *\n   * @return {AST} The AST\n   */\n  async parse() {\n    const ast = {\n      type: 'Program',\n      body: [],\n    };\n\n    while (!this.eof()) {\n      ast.body.push(this.walk(ast.body));\n    }\n\n    if (this.state === PARSER_STATE.ERROR) {\n      console.error(`Errors encountered while parsing source`);\n      return ast;\n    }\n\n    return ast;\n  }\n\n  /**\n   * Returns true if we've reached the end of the token list, otherwise false.\n   *\n   * @return {boolean}\n   */\n  eof() {\n    return this.cursor >= this.tokens.length;\n  }\n\n  /**\n   * Prints an error with location information to `stderr`\n   * and sets the parser state to `PARSER_STATE.ERROR`\n   *\n   * @param {string} error\n   * @return {void}\n   */\n  report(error) {\n    this.state = PARSER_STATE.ERROR;\n    console.error(`Error (${this.cursor}): ${error}`);\n  }\n}\n\n/**\n * Walks token list and returns an AST.\n *\n * @memberof radspec/parser\n * @param  {Array<Token>} tokens\n * @return {AST} The AST\n */\nexport function parse(tokens) {\n  return new Parser(tokens).parse();\n}\n"],"file":"index.js"}