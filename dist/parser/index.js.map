{"version":3,"sources":["../../src/parser/index.js"],"names":["PARSER_STATE","OK","ERROR","Parser","constructor","tokens","state","cursor","consume","previous","peek","matches","expected","eof","type","comparison","astBody","node","addition","operator","right","left","predicate","report","multiplication","power","unary","identifier","value","previousNode","length","pop","property","target","callee","inputs","functionInputs","outputs","push","helper","name","primary","NUMBER","STRING","HEXADECIMAL","BOOLEAN","expression","body","input","walk","token","parse","ast","console","error"],"mappings":"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","sourcesContent":["/**\n * @module radspec/parser\n */\n\n/**\n * A token.\n * @typedef {Object} Token\n * @property {string} type The token type\n * @property {*?} value The value of the token\n */\n\n/**\n * An AST node.\n * @typedef {Object} Node\n * @property {string} type The node type\n */\n/**\n * An AST.\n * @typedef {Object} AST\n * @property {string} type\n * @property {Array<Node>} body The AST nodes\n */\n\n/**\n * Enum for parser state.\n *\n * @readonly\n * @enum {string}\n */\nconst PARSER_STATE = {\n  OK: 'OK',\n  ERROR: 'ERROR'\n}\n\n/**\n * Parses a token list into an AST.\n *\n * @class Parser\n * @param {Array<Token>} tokens\n * @property {string} state The state of the parser (`OK` or `ERROR`)\n * @property {Array<Token>} tokens\n * @property {number} cursor\n */\nexport class Parser {\n  constructor (tokens) {\n    this.state = PARSER_STATE.OK\n\n    this.tokens = tokens\n    this.cursor = 0\n  }\n\n  /**\n   * Get the current token and increase the cursor by 1\n   *\n   * @return {Token}\n   */\n  consume () {\n    this.cursor++\n\n    return this.tokens[this.cursor - 1]\n  }\n\n  /**\n   * Get the previous token.\n   *\n   * @return {Token}\n   */\n  previous () {\n    return this.tokens[this.cursor - 1]\n  }\n\n  /**\n   * Get the token under the cursor without consuming it.\n   *\n   * @return {Token}\n   */\n  peek () {\n    return this.tokens[this.cursor]\n  }\n\n  /**\n   * Checks if the type of the next token matches any of the expected types.\n   *\n   * Increases the cursor by 1 if the token matches.\n   *\n   * @param {...string} expected The expected types\n   * @return {boolean} True if the next token matches, otherwise false\n   */\n  matches (...expected) {\n    if (this.eof()) return false\n    for (let type of expected) {\n      if (this.peek().type === type) {\n        this.cursor++\n        return true\n      }\n    }\n\n    return false\n  }\n\n  /**\n   * Try to parse comparison operators.\n   *\n   * @param  {Array<Node>} astBody Subtree of AST being walked\n   * @return {Node}\n   */\n  comparison (astBody) {\n    let node = this.addition(astBody)\n\n    while (this.matches('GREATER', 'GREATER_EQUAL', 'LESS', 'LESS_EQUAL', 'EQUAL_EQUAL', 'BANG_EQUAL')) {\n      let operator = this.previous().type\n      let right = this.addition(astBody)\n      node = {\n        type: 'ComparisonExpression',\n        operator,\n        left: node,\n        right\n      }\n    }\n\n    if (this.matches('QUESTION_MARK')) {\n      node = {\n        type: 'TernaryExpression',\n        predicate: node,\n        left: this.comparison(astBody)\n      }\n\n      if (!this.matches('COLON')) {\n        this.report('Half-baked ternary (expected colon)')\n      }\n\n      node.right = this.comparison(astBody)\n    }\n\n    if (this.matches('DOUBLE_VERTICAL_BAR')) {\n      node = {\n        left: node,\n        right: this.comparison(),\n        type: 'DefaultExpression'\n      }\n    }\n\n    return node\n  }\n\n  /**\n   * Try to parse arithmetic operators.\n   *\n   * @param  {Array<Node>} astBody Subtree of AST being walked\n   * @return {Node}\n   */\n  addition (astBody) {\n    let node = this.multiplication(astBody)\n\n    while (this.matches('MINUS', 'PLUS')) {\n      let operator = this.previous().type\n      let right = this.multiplication(astBody)\n      node = {\n        type: 'BinaryExpression',\n        operator,\n        left: node,\n        right\n      }\n    }\n\n    return node\n  }\n\n  /**\n   * Try to parse binary operators.\n   *\n   * @param  {Array<Node>} astBody Subtree of AST being walked\n   * @return {Node}\n   */\n  multiplication (astBody) {\n    let node = this.power(astBody)\n\n    while (this.matches('SLASH', 'STAR', 'MODULO')) {\n      let operator = this.previous().type\n      let right = this.power(astBody)\n\n      node = {\n        type: 'BinaryExpression',\n        operator,\n        left: node,\n        right\n      }\n    }\n\n    return node\n  }\n\n  /**\n   * Try to parse exponential operators.\n   *\n   * @param  {Array<Node>} astBody Subtree of AST being walked\n   * @return {Node}\n   */\n  power (astBody) {\n    let node = this.unary(astBody)\n\n    while (this.matches('POWER')) {\n      let operator = this.previous().type\n      let right = this.unary(astBody)\n\n      node = {\n        type: 'BinaryExpression',\n        operator,\n        left: node,\n        right\n      }\n    }\n\n    return node\n  }\n\n  /**\n   * Try to parse unary operators.\n   *\n   * @param  {Array<Node>} astBody Subtree of AST being walked\n   * @return {Node}\n   */\n  unary (astBody) {\n    if (this.matches('BANG', 'MINUS')) {\n      let operator = this.previous().type\n      let right = this.unary(astBody)\n\n      return {\n        type: 'UnaryExpression',\n        operator,\n        right: right\n      }\n    }\n\n    return this.identifier(astBody)\n  }\n\n  /**\n   * Try to parse identifiers and call expressions.\n   *\n   * @param  {Array<Node>} astBody Subtree of AST being walked\n   * @return {Node}\n   */\n  identifier (astBody) {\n    let node\n\n    if (this.matches('IDENTIFIER')) {\n      node = {\n        type: 'Identifier',\n        value: this.previous().value\n      }\n    }\n\n    if (!node) {\n      const previousNode = astBody.length && astBody[astBody.length - 1]\n      if (previousNode && (\n        previousNode.type === 'Identifier' ||\n        previousNode.type === 'GroupedExpression' ||\n        previousNode.type === 'CallExpression'\n      )) {\n        node = previousNode\n        // Consume the last node as part of this node\n        astBody.pop()\n      }\n    }\n\n    if (node) {\n      while (this.matches('DOT')) {\n        let property = this.consume().value\n\n        node = {\n          type: 'PropertyAccessExpression',\n          target: node,\n          property\n        }\n      }\n\n      if (this.matches('LEFT_PAREN')) {\n        node = {\n          type: 'CallExpression',\n          target: node.target,\n          callee: node.property,\n          inputs: this.functionInputs(astBody),\n          outputs: []\n        }\n\n        if (this.eof()) {\n          // TODO Better error\n          this.report('Unterminated call expression')\n        }\n\n        node.outputs.push({\n          type: this.type()\n        })\n      }\n\n      return node\n    }\n\n    return this.helper(astBody)\n  }\n\n  /**\n   * Try to parse helper functions\n   *\n   * @param  {Array<Node>} astBody Subtree of AST being walked\n   * @return {Node}\n   */\n  helper (astBody) {\n    if (this.matches('AT')) {\n      const identifier = this.consume()\n      const name = identifier.value\n\n      if (identifier.type !== 'IDENTIFIER') {\n        this.report(`Invalid helper function name '${name}' provided after @`)\n      }\n\n      const node = {\n        type: 'HelperFunction',\n        name: name\n      }\n\n      if (this.matches('LEFT_PAREN')) {\n        node.inputs = this.functionInputs(astBody)\n      } else {\n        // There is actually no good reason not to allow calling a helper without ()\n        // this.report(`Expected '(' for executing helper function`)\n      }\n\n      return node\n    }\n\n    return this.primary(astBody)\n  }\n\n  /**\n   * Try to parse primaries (literals).\n   *\n   * @param  {Array<Node>} astBody Subtree of AST being walked\n   * @return {Node}\n   */\n  primary (astBody) {\n    if (this.matches('NUMBER', 'STRING', 'HEXADECIMAL', 'BOOLEAN')) {\n      let type = {\n        NUMBER: 'NumberLiteral',\n        STRING: 'StringLiteral',\n        HEXADECIMAL: 'BytesLiteral',\n        BOOLEAN: 'BoolLiteral'\n      }[this.previous().type]\n\n      return {\n        type,\n        value: this.previous().value\n      }\n    }\n\n    if (this.matches('LEFT_PAREN')) {\n      let expression\n\n      do {\n        // Keep munching expressions in the context of the current expression\n        expression = this.comparison(expression ? [expression] : [])\n      } while (!this.eof() && !this.matches('RIGHT_PAREN'))\n\n      if (this.eof()) {\n        this.report('Unterminated grouping')\n      }\n\n      return {\n        type: 'GroupedExpression',\n        body: expression\n      }\n    }\n\n    this.report(`Unknown token \"${this.consume().type}\"`)\n  }\n\n  /**\n   * Try to parse a type.\n   *\n   * @return {string} The type\n   */\n  type () {\n    if (!this.matches('COLON') &&\n      this.peek().type !== 'TYPE') {\n      // TODO Better error\n      this.report(`Expected a type, got \"${this.peek().type}\"`)\n    }\n\n    return this.consume().value\n  }\n\n  /**\n   * Try to parse function arguments.\n   *\n   * @param  {Array<Node>} astBody Subtree of AST being walked\n   * @return {Array<Node>}\n   */\n  functionInputs (astBody) {\n    const inputs = []\n\n    while (!this.eof() && !this.matches('RIGHT_PAREN')) {\n      const input = this.comparison(astBody)\n      if (!input.type) {\n        input.type = this.type()\n      } else if (this.matches('COLON')) {\n        this.report(`Unexpected type (already inferred type of parameter)`)\n      }\n\n      inputs.push(input)\n\n      // Break if the next character is not a comma or a right parenthesis\n      // If this is true, then we are specifying more parameters without\n      // delimiting them using comma.\n      if (!this.matches('COMMA') &&\n        this.peek().type !== 'RIGHT_PAREN') break\n    }\n\n    return inputs\n  }\n\n  /**\n   * Walk all possible paths and try to parse a single node\n   * from the list of tokens.\n   *\n   * @param  {Array<Node>} astBody Subtree of AST being walked\n   * @return {Node}\n   */\n  walk (astBody) {\n    let token = this.peek()\n\n    if (token.type === 'MONOLOGUE') {\n      return {\n        type: 'MonologueStatement',\n        value: this.consume().value\n      }\n    }\n\n    if (token.type === 'TICK') {\n      let node = {\n        type: 'ExpressionStatement',\n        body: []\n      }\n\n      this.matches('TICK')\n\n      while (!this.eof() && this.peek().type !== 'TICK') {\n        node.body.push(this.walk(node.body))\n      }\n\n      if (this.eof()) {\n        this.report('Unterminated expression')\n      }\n\n      this.matches('TICK')\n\n      return node\n    }\n\n    return this.comparison(astBody)\n  }\n\n  /**\n   * Walks the token list and returns an AST.\n   *\n   * @return {AST} The AST\n   */\n  async parse () {\n    let ast = {\n      type: 'Program',\n      body: []\n    }\n\n    while (!this.eof()) {\n      ast.body.push(this.walk(ast.body))\n    }\n\n    if (this.state === PARSER_STATE.ERROR) {\n      console.error(`Errors encountered while parsing source`)\n      return ast\n    }\n\n    return ast\n  }\n\n  /**\n   * Returns true if we've reached the end of the token list, otherwise false.\n   *\n   * @return {boolean}\n   */\n  eof () {\n    return this.cursor >= this.tokens.length\n  }\n\n  /**\n   * Prints an error with location information to `stderr`\n   * and sets the parser state to `PARSER_STATE.ERROR`\n   *\n   * @param {string} error\n   * @return {void}\n   */\n  report (error) {\n    this.state = PARSER_STATE.ERROR\n    console.error(\n      `Error (${this.cursor}): ${error}`\n    )\n  }\n}\n\n/**\n * Walks token list and returns an AST.\n *\n * @memberof radspec/parser\n * @param  {Array<Token>} tokens\n * @return {AST} The AST\n */\nexport function parse (tokens) {\n  return new Parser(tokens).parse()\n}\n"],"file":"index.js"}