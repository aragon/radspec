{"version":3,"sources":["../../src/scanner/index.js"],"names":["SCANNER_STATE","OK","ERROR","Scanner","constructor","source","state","isInExpression","cursor","tokens","scanToken","current","consume","emitToken","monologue","peek","eof","matches","report","NUMBERS","HEX","test","number","type","IDENTIFIERS","identifier","types","isType","string","value","token","push","expected","scan","console","error","length"],"mappings":"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","sourcesContent":["/**\n * @module radspec/scanner\n */\nimport types from '../types';\n\n/**\n * Enum for scanner state.\n *\n * @readonly\n * @enum {string}\n */\nconst SCANNER_STATE = {\n  OK: 'OK',\n  ERROR: 'ERROR',\n};\n\n/**\n * A scanner that identifies tokens in a source string.\n *\n * @class Scanner\n * @param {string} source The source code\n * @property {string} state The state of the parser (`OK` or `ERROR`)\n * @property {string} source The source code\n * @property {number} cursor\n * @property {Array<Token>} tokens The currently identified tokens\n */\nexport class Scanner {\n  constructor(source) {\n    this.state = SCANNER_STATE.OK;\n    this.isInExpression = false;\n\n    this.source = source;\n    this.cursor = 0;\n\n    this.tokens = [];\n  }\n\n  /**\n   * Scans a single token from source and pushes it to `Scanner.tokens`.\n   *\n   * @return {void}\n   */\n  scanToken() {\n    const current = this.consume();\n\n    if (current === '`') {\n      this.isInExpression = !this.isInExpression;\n      this.emitToken('TICK');\n      return;\n    }\n\n    // We haven't hit a tick yet, so we're not in an expression\n    if (!this.isInExpression) {\n      // Scan until tick\n      let monologue = current;\n      while (this.peek() !== '`' && !this.eof()) {\n        monologue += this.consume();\n      }\n      this.emitToken('MONOLOGUE', monologue);\n      return;\n    }\n\n    switch (current) {\n      // Single character tokens\n      case '(':\n        this.emitToken('LEFT_PAREN');\n        break;\n      case ')':\n        this.emitToken('RIGHT_PAREN');\n        break;\n      case ',':\n        this.emitToken('COMMA');\n        break;\n      case '.':\n        this.emitToken('DOT');\n        break;\n      case ':':\n        this.emitToken('COLON');\n        break;\n      case '-':\n        this.emitToken('MINUS');\n        break;\n      case '+':\n        this.emitToken('PLUS');\n        break;\n      case '^':\n        this.emitToken('POWER');\n        break;\n      case '*':\n        this.emitToken('STAR');\n        break;\n      case '/':\n        this.emitToken('SLASH');\n        break;\n      case '%':\n        this.emitToken('MODULO');\n        break;\n      case '?':\n        this.emitToken('QUESTION_MARK');\n        break;\n      case '@':\n        this.emitToken('AT');\n        break;\n\n      // One or two character tokens\n      case '!':\n        this.emitToken(this.matches('=') ? 'BANG_EQUAL' : 'BANG');\n        break;\n      case '=':\n        this.emitToken(this.matches('=') ? 'EQUAL_EQUAL' : 'EQUAL');\n        break;\n      case '<':\n        this.emitToken(this.matches('=') ? 'LESS_EQUAL' : 'LESS');\n        break;\n      case '>':\n        this.emitToken(this.matches('=') ? 'GREATER_EQUAL' : 'GREATER');\n        break;\n\n      // Two character tokens\n      case '|':\n        if (this.matches('|')) {\n          this.emitToken('DOUBLE_VERTICAL_BAR');\n        } else {\n          this.report(`Unexpected single \"|\" (expecting two)`);\n        }\n        break;\n\n      // Whitespace\n      case ' ':\n      case '\\r':\n      case '\\n':\n      case '\\t':\n        break;\n\n      // Multi-character tokens\n      default:\n        const NUMBERS = /[0-9]/;\n        const HEX = /[0-9a-f]/i;\n        if (NUMBERS.test(current)) {\n          let number = current;\n          let type = 'NUMBER';\n\n          // Detect hexadecimals\n          if (current === '0' && this.peek() === 'x') {\n            type = 'HEXADECIMAL';\n            number += this.consume();\n\n            while (HEX.test(this.peek())) {\n              number += this.consume();\n            }\n          } else {\n            while (NUMBERS.test(this.peek())) {\n              number += this.consume();\n            }\n          }\n\n          this.emitToken(type, number);\n          break;\n        }\n\n        const IDENTIFIERS = /[_$a-z0-9]/i;\n        if (IDENTIFIERS.test(current)) {\n          let identifier = current;\n          while (IDENTIFIERS.test(this.peek())) {\n            identifier += this.consume();\n          }\n\n          if (identifier === 'true' || identifier === 'false') {\n            this.emitToken('BOOLEAN', identifier);\n            break;\n          }\n\n          if (types.isType(identifier)) {\n            this.emitToken('TYPE', identifier);\n          } else {\n            this.emitToken('IDENTIFIER', identifier);\n          }\n          break;\n        }\n\n        if (current === `'` || current === `\"`) {\n          let string = '';\n          while (!this.matches(`'`) && !this.matches(`\"`)) {\n            string += this.consume();\n          }\n          this.emitToken('STRING', string);\n          break;\n        }\n\n        this.report(`Unexpected character \"${current}\"`);\n    }\n  }\n\n  /**\n   * Push a token to `Scanner.tokens`\n   *\n   * @param {string} type The token type\n   * @param {string?} value The token value\n   * @return {void}\n   */\n  emitToken(type, value) {\n    const token = { type };\n    if (value) token.value = value;\n\n    this.tokens.push(token);\n  }\n\n  /**\n   * Get the current character and increase the cursor by 1\n   *\n   * @return {string}\n   */\n  consume() {\n    this.cursor++;\n\n    return this.source[this.cursor - 1];\n  }\n\n  /**\n   * Get the character under the cursor without consuming it.\n   *\n   * @return {string}\n   */\n  peek() {\n    return this.source[this.cursor];\n  }\n\n  /**\n   * Checks if the next character matches an expected one.\n   *\n   * Increases the cursor by 1 if the character matches.\n   *\n   * @param {string} expected The character to expect\n   * @return {boolean} True if the next character matches, otherise false\n   */\n  matches(expected) {\n    if (this.eof()) return false;\n    if (this.peek() !== expected) {\n      return false;\n    }\n\n    this.cursor++;\n    return true;\n  }\n\n  /**\n   * Scans source and returns a list of tokens.\n   *\n   * @return {Array<Token>}\n   */\n  async scan() {\n    while (!this.eof()) {\n      this.scanToken();\n    }\n\n    if (this.state === SCANNER_STATE.ERROR) {\n      console.error(`Errors encountered while scanning source`);\n      return;\n    }\n\n    return this.tokens;\n  }\n\n  /**\n   * Returns true if we've reached the end of source, otherwise false.\n   *\n   * @return {boolean}\n   */\n  eof() {\n    return this.cursor >= this.source.length;\n  }\n\n  /**\n   * Prints an error with location information to `stderr`\n   * and sets the scanner state to `SCANNER_STATE.ERROR`\n   *\n   * @param {string} error\n   * @return {void}\n   */\n  report(error) {\n    this.state = SCANNER_STATE.ERROR;\n    console.error(`Error (${this.cursor}): ${error}`);\n  }\n}\n\n/**\n * Scans source and returns a list of tokens.\n *\n * @memberof radspec/scanner\n * @param  {string} source\n * @return {Array<Token>}\n */\nexport function scan(source) {\n  return new Scanner(source).scan();\n}\n"],"file":"index.js"}